#include <algorithm>
#include <chrono>
#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <random>
#include <stdexcept>
#include <string>
#include <vector>

#include "Algorithms/Buckets/BCCHClosestPoiQuery.h"
#include "Algorithms/Buckets/BCHClosestPoiQuery.h"
#include "Algorithms/CCH/CCH.h"
#include "Algorithms/CCH/CCHClosestPoiQuery.h"
#include "Algorithms/CCH/CCHMetric.h"
#include "Algorithms/CH/CH.h"
#include "Algorithms/Dijkstra/Dijkstra.h"
#include "Algorithms/Dijkstra/DijkstraClosestPoiQuery.h"
#include "DataStructures/Graph/Attributes/LengthAttribute.h"
#include "DataStructures/Graph/Attributes/TravelTimeAttribute.h"
#include "DataStructures/Graph/Graph.h"
#include "DataStructures/Labels/BasicLabelSet.h"
#include "DataStructures/Labels/ParentInfo.h"
#include "DataStructures/Partitioning/SeparatorDecomposition.h"
#include "Tools/CommandLine/CommandLineParser.h"
#include "Tools/CommandLine/ProgressBar.h"
#include "Tools/StringHelpers.h"
#include "Tools/Timer.h"

inline void printUsage() {
  std::cout <<
      "Usage: RunPoiAlgo -a Dij  -b <nums> -p <nums> -g <file> -o <file>\n"
      "       RunPoiAlgo -a BCH  -b <nums> -p <nums> -g <file> -h <file> -o <file>\n"
      "       RunPoiAlgo -a BCCH -b <nums> -p <nums> -g <file> -d <file> -o <file>\n"
      "       RunPoiAlgo -a CCH  -b <nums> -p <nums> -g <file> -d <file> -o <file>\n"
      "Run the selection and query phase of various closest-POI algorithms. POI sets\n"
      "are generated by growing a Dijkstra ball of size b, and picking p vertices at\n"
      "random from it. For every combination of b and p, the program generates n POI\n"
      "sets, and runs m queries per set.\n"
      "  -l                use physical lengths as metric (default: travel times)\n"
      "  -n <num>          generate <num> POI sets per comb of b and p (default: 100)\n"
      "  -m <num>          run <num> queries per POI set (default: 100)\n"
      "  -s <seed>         start the random number generator with <seed> (default: 0)\n"
      "  -a <algo>         use <algo> as closest-POI algorithm\n"
      "                     possible values: Dij BCH BCCH CCH (default)\n"
      "  -b <nums>         space-separated list of ball sizes\n"
      "  -p <nums>         space-separated list of POI set sizes\n"
      "  -k <nums>         space-separated list of POI amounts to be reported\n"
      "  -g <file>         input graph in binary format\n"
      "  -h <file>         standard contraction hierarchy in binary format\n"
      "  -d <file>         separator decomposition in binary format\n"
      "  -o <file>         place output in <file>\n"
      "  -help             display this help and exit\n";
}

// The stopping criterion for the Dijkstra search that grows the balls. We stop when a fixed number
// of vertices is reached.
struct StopWhenFixedSearchSpaceSizeReached {
  // Creates a stopping criterion for the Dijkstra search that grows the balls.
  StopWhenFixedSearchSpaceSizeReached(const int& ballSize, std::vector<int32_t>& ball) noexcept
      : ballSize(ballSize), ball(ball) {}

  // Returns true if the search can be stopped at v.
  template <typename DistanceLabelT, typename DistanceLabelContainerT>
  bool operator()(const int v, const DistanceLabelT&, const DistanceLabelContainerT&) {
    ball.push_back(v);
    return ball.size() == ballSize;
  }

  const int& ballSize;        // The number of vertices to be reached.
  std::vector<int32_t>& ball; // All vertices reached so far.
};

// Runs the selection and query phase of the specified closest-POI algorithm.
template <typename GraphT, typename MappingT, typename ClosestPoiAlgoT>
inline void runClosestPoiAlgorithm(
    const CommandLineParser& clp, const GraphT& graph, MappingT translate, ClosestPoiAlgoT& algo) {
  const auto seed = clp.getValue<int>("s", 0);
  const auto numPoiSetsPerComb = clp.getValue<int>("n", 100);
  const auto numQueriesPerPoiSet = clp.getValue<int>("m", 100);
  auto ballSizes = clp.getValues<int>("b");
  auto poiSetSizes = clp.getValues<int>("p");
  auto maxPoiAmounts = clp.getValues<int>("k");
  auto outputFileName = clp.getValue<std::string>("o");
  if (endsWith(outputFileName, ".csv"))
    outputFileName = outputFileName.substr(0, outputFileName.size() - 4);

  if (!ballSizes.empty() && !poiSetSizes.empty()) {
    std::sort(ballSizes.begin(), ballSizes.end());
    std::sort(poiSetSizes.begin(), poiSetSizes.end());
    if (poiSetSizes.back() > ballSizes.front())
      throw std::invalid_argument("POI set sizes must not be larger than ball sizes");
  }

  std::minstd_rand gen(seed + 1);
  std::uniform_int_distribution<> randomVertex(0, graph.numVertices() - 1);

  int ballSize;
  std::vector<int32_t> ball;
  using LabelSet = BasicLabelSet<0, ParentInfo::NO_PARENT_INFO>;
  using Dij = Dijkstra<GraphT, TravelTimeAttribute, LabelSet, StopWhenFixedSearchSpaceSizeReached>;
  Dij dijkstra(graph, {ballSize, ball});

  std::ofstream selectionStats(outputFileName + ".index.csv");
  if (!selectionStats.good())
    throw std::invalid_argument("file cannot be opened -- '" + outputFileName + ".index.csv'");
  selectionStats << "ball_size,num_pois,space,time\n";

  std::ofstream queryStats(outputFileName + ".query.csv");
  if (!queryStats.good())
    throw std::invalid_argument("file cannot be opened -- '" + outputFileName + ".query.csv'");
  queryStats << "ball_size,num_pois,max_pois,total_distance,time\n";

  for (const auto b : ballSizes) {
    std::cout << "Ball size " << b << ":\t";
    ProgressBar bar(numPoiSetsPerComb);

    for (auto i = 0; i < numPoiSetsPerComb; ++i) {
      // Grow a Dijkstra ball from a random center.
      const auto center = randomVertex(gen);
      ballSize = b;
      ball.clear();
      dijkstra.run(center);
      std::transform(ball.begin(), ball.end(), ball.begin(), translate);

      for (const auto p : poiSetSizes) {
        // Pick a POI set uniformly at random from the Dijkstra ball.
        std::shuffle(ball.begin(), ball.end(), gen);
        std::vector<int32_t> pointsOfInterest(ball.begin(), ball.begin() + p);
        std::sort(pointsOfInterest.begin(), pointsOfInterest.end());

        // Run the selection phase of the closest-POI algorithm.
        Timer selectionTimer;
        const auto poiIndex = algo.buildPoiIndexFor(pointsOfInterest);
        const auto selectionTime = selectionTimer.elapsed<std::chrono::nanoseconds>();
        const auto selectionSpace = poiIndex.spaceConsumption();
        selectionStats << b << ',' << p << ',' << selectionSpace << ',' << selectionTime << '\n';

        for (auto j = 0; j < numQueriesPerPoiSet; ++j) {
          for (const auto k : maxPoiAmounts) {
            // Run the query phase of the closest-POI algorithm.
            const auto source = translate(randomVertex(gen));
            Timer queryTimer;
            const auto& closestPois = algo.findClosestPois(source, poiIndex, k);
            const auto queryTime = queryTimer.elapsed<std::chrono::nanoseconds>();

            // Compute the checksum for the query.
            int64_t checksum = 0;
            for (const auto& poi : closestPois)
              checksum += poi.dist;
            queryStats << b << ',' << p << ',' << k << ',' << checksum << ',' << queryTime << '\n';
          }
        }
      }
      ++bar;
    }
    std::cout << "done." << '\n';
  }
}

int main(int argc, char* argv[]) {
  try {
    CommandLineParser clp(argc, argv);
    if (clp.isSet("help")) {
      printUsage();
      return EXIT_SUCCESS;
    }

    // Parse command-line options.
    const auto useLengths = clp.isSet("l");
    const auto algorithmName = clp.getValue<std::string>("a", "CCH");
    const auto graphFileName = clp.getValue<std::string>("g");
    const auto hierarchyFileName = clp.getValue<std::string>("h");
    const auto sepDecompFileName = clp.getValue<std::string>("d");

    // Read the input graph from file.
    std::cout << "Reading input graph from file... " << std::flush;
    std::ifstream graphFile(graphFileName, std::ios::binary);
    if (!graphFile.good())
      throw std::invalid_argument("file not found -- '" + graphFileName + "'");
    using InputGraph = StaticGraph<VertexAttrs<>, EdgeAttrs<LengthAttribute, TravelTimeAttribute>>;
    InputGraph graph(graphFile);
    graphFile.close();
    if (useLengths)
      FORALL_EDGES(graph, e)
        graph.travelTime(e) = graph.length(e);
    std::cout << "done.\n";

    // Run a closest-POI algorithm.
    if (algorithmName == "Dij") {
      DijkstraClosestPoiQuery<InputGraph, TravelTimeAttribute> closestPoiAlgo(graph);
      runClosestPoiAlgorithm(clp, graph, [](const int v) { return v; }, closestPoiAlgo);
    } else if (algorithmName == "BCH") {
      // Read the CH from file.
      std::cout << "Reading CH from file... " << std::flush;
      std::ifstream hierarchyFile(hierarchyFileName, std::ios::binary);
      if (!hierarchyFile.good())
        throw std::invalid_argument("file not found -- '" + hierarchyFileName + "'");
      CH ch(hierarchyFile);
      hierarchyFile.close();
      std::cout << "done.\n";

      BCHClosestPoiQuery closestPoiAlgo(ch);
      runClosestPoiAlgorithm(clp, graph, [&](const int v) { return ch.rank(v); }, closestPoiAlgo);
    } else if (algorithmName == "BCCH" || algorithmName == "CCH") {
      // Read the separator decomposition from file.
      std::cout << "Reading separator decomposition from file... " << std::flush;
      std::ifstream sepDecompFile(sepDecompFileName, std::ios::binary);
      if (!sepDecompFile.good())
        throw std::invalid_argument("file not found -- '" + sepDecompFileName + "'");
      SeparatorDecomposition sepDecomp;
      sepDecomp.readFrom(sepDecompFile);
      sepDecompFile.close();
      std::cout << "done.\n";

      // Build and customize a CCH.
      std::cout << "Building and customizing CCH... " << std::flush;
      CCH cch;
      cch.preprocess(graph, sepDecomp);
      CCHMetric metric(cch, &graph.travelTime(0));
      const auto minWeightedCH = metric.buildMinimumWeightedCH();
      auto translate = [&](const int v) { return minWeightedCH.rank(v); };
      std::cout << "done.\n";

      if (algorithmName == "BCCH") {
        BCCHClosestPoiQuery closestPoiAlgo(cch, minWeightedCH);
        runClosestPoiAlgorithm(clp, graph, translate, closestPoiAlgo);
      } else {
        CCHClosestPoiQuery closestPoiAlgo(cch, minWeightedCH);
        runClosestPoiAlgorithm(clp, graph, translate, closestPoiAlgo);
      }
    } else {
      throw std::invalid_argument("invalid closest-POI algorithm -- '" + algorithmName + "'");
    }
  } catch (std::exception& e) {
    std::cerr << argv[0] << ": " << e.what() << '\n';
    std::cerr << "Try '" << argv[0] <<" -help' for more information.\n";
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
